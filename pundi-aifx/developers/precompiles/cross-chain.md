# CrossChain Precompiled

Address: `0x0000000000000000000000000000000000001004`

Interface: [ICrossChain](cross-chain.md#crosschain)

ABI: [ICrossChain](https://github.com/PundiAI/fx-core/blob/bf74d4a73e3478b03122fe8ddc4c447cb7017634/contract/ICrossChain.go#LL34C11-L34C11)

Overview: Use crossChain precompiled contract to call some functions of the crossChain module, such as: crossChain, cancelSendToExternal, etc.

## Introduction

Before accessing the cross-chain precompiled contract, the cross-chain operations of the precompile can be called via the hook method.

Using a simple example, a specific event, say: `CrossChain`, is added to a token contract; and when the token contract is deployed and successfully executes a transaction that emits this specific event, the EVM module in f(x)Core will parse the event generated by the contract. If the emitted event is relevant to the cross-chain precompiled contract, the corresponding cross-chain logic will be executed based on the data in the `CrossChain` event.

## Use-case Reference

### Low-level Call ([Sample contract](https://github.com/PundiAI/fx-core/blob/a16fa0bcf02f4bfde9135f7df37478fe76697185/solidity/contracts/bridge/ICrosschain.sol#L12))

```solidity
function crossChain(
    address _token,
    string memory _receipt,
    uint256 _amount,
    uint256 _fee,
    bytes32 _target,
    string memory _memo
) internal returns (bool) {
    (bool result, bytes memory data) = CROSS_CHAIN_ADDRESS.call{
        value: msg.value
    }(Encode.crossChain(_token, _receipt, _amount, _fee, _target, _memo));
    Decode.ok(result, data, "cross-chain failed");
    return Decode.crossChain(data);
}
```

`Encode.crossChain` encodes the `crossChain` method and its parameters using `abi.encodeWithSignature` to create a bytes array that will be sent to the cross-chain precompiled contract to invoke the corresponding `crossChain` method along with the encoded parameters.

### Contract Interface ([Sample Contract](https://github.com/PundiAI/fx-core/blob/a16fa0bcf02f4bfde9135f7df37478fe76697185/solidity/contracts/bridge/ICrosschain.sol#L12))

```solidity
interface ICrossChain {
    function crossChain(
        address _token,
        string memory _receipt,
        uint256 _amount,
        uint256 _fee,
        bytes32 _target,
        string memory _memo
    ) external payable returns (bool _result);
}

contract CrossChainTest {
    ICrossChain crossChain = 0x0000000000000000000000000000000000001004;

    function crossChain(
        address _token,
        string memory _receipt,
        uint256 _amount,
        uint256 _fee,
        bytes32 _target,
        string memory _memo
    ) external payable returns (bool) {
        bool success = _crossChain.crossChain(_token, _receipt, _amount, _fee, _target, _memo);
        require(success, "crossChain failed");
    }
}
```

The contract interface method is relatively simple. It only needs to define the contract interface with the appropriate method, and parameters are simply passed into it like a regular call to another contract’s function. It does not require encoding the method and its parameters since the contract interface takes care of that, however the reason cannot be obtained in the event of a failure.

The `crossChain` method has the `payable` keyword, so it can directly cross-chain f(x)Core’s native currency: FX. Note that there are some differences between executing a cross-chain transaction for FX and an ERC20 token:

* When using cross-chain for FX, `_token` needs to be the zero address (`0x0000000000000000000000000000000000000000`), and fill in: `value = _amount + _fee`.
* When using cross-chain for ERC20 token, an approval must first be granted to the address: `0x0000000000000000000000000000000000001004`, and the authorized amount must be equals to: `amount = _amount + _fee`.

## Method

### crossChain

send token from f(x)Core to other chain, like ethereum, pundix, etc.

{% hint style="info" %}
if token is erc20, must be approved before calling this method
{% endhint %}

```solidity
function crossChain(
    address _token,
    string memory _receipt,
    uint256 _amount,
    uint256 _fee,
    bytes32 _target,
    string memory _memo
) external payable returns (result bool);
```

* `_token`: the token address on the f(x)Core([Tokens](../cross-chain/fx-core.md))
  * if token is origin token, \_token address is `0x0000000000000000000000000000000000000000`
* `_receipt`: the receipt address on the target chain
* `_amount`: the amount of the token to be cross chain
* `_fee`: the fee of the token to be cross chain
  * if cross chain to cosmos chain, \_fee is `0`
* `_target`: the target of the token on the target chain(more detail see [Target](../cross-chain/target.md)
  * \_target represents cross chain destination, such as chain `ethereum`, `pundix`
  * destination ethereum: \_target is `eth`
  * destination other cosmos chain(example Pundix): \_target is `ibc/{id}/{prefix}`.
    * `id` is the channel id of the target chain on f(x)Core(examples: Pundix: 0)
    * `prefix` is the address prefix of the target chain(examples: Pundix: px)
* `_memo`: the memo of cross chain

{% hint style="info" %}
\_target convert string to bytes, if less than 32, fill in 0 in behind, until 32 bytes
{% endhint %}

crossChain event

```solidity
event CrossChain(
    address indexed sender,
    address indexed token,
    string denom,
    string receipt,
    uint256 amount,
    uint256 fee,
    bytes32 target,
    string memo
);
```

* `sender`: the sender address
* `token`: the erc20 token address on the f(x)Core
* `denom`: the cross chain token denom
* `receipt`: the receipt address on the target chain
* `amount`: the amount of the token to be cross chain
* `fee`: the fee of the token to be cross chain
* `target`: the target of cross chain
* `memo`: the memo of cross chain

### cancelSendToExternal

cancel cross chain to external chain, like ethereum, bsc, etc.

{% hint style="info" %}
only cancel send to external chain(ethereum,bsc, etc.) transaction, can't cancel send to cosmos chain(pundix, cosmoshub, etc.) transaction.
{% endhint %}

```solidity
function cancelSendToExternal(
    string memory _chain,
    uint256 _txid
) external returns (result bool);
```

* `_chain`: the module name of the cross chain, like eth, bsc, etc.
* `_txid`: the txid of the cross chain transaction

cancelSendToExternal event

```solidity
event CancelSendToExternal(
    address indexed sender,
    string chain,
    uint256 txID
);
```

* `sender`: the sender address
* `chain`: the module name of the cross chain, like eth, bsc, etc.
* `txID`: the txid of the cross chain transaction

### increaseBridgeFee

increase fee for send to external chain transaction

{% hint style="info" %}
only increase fee for send to external chain transaction, can't increase fee for send to cosmos chain transaction
{% endhint %}

{% hint style="info" %}
not necessarily the initiator of the cross chain transaction, anyone can increase the fee for the cross chain transaction
{% endhint %}

{% hint style="info" %}
if token is erc20, must be approved before calling this method
{% endhint %}

```solidity
function increaseBridgeFee(
    string memory _chain,
    uint256 _txid,
    address _token,
    uint256 _fee
) external payable returns (result bool);
```

* `_chain`: the chain name of the cross chain, like eth, bsc, [etc](../cross-chain/target.md#fxcore-cross-chain-with-target)(not contain cosmos chain).
* `_txid`: the txid of the cross chain transaction
* `_token`: the address of cross chain fee token([Tokens](../cross-chain/fx-core.md))
  * if token is origin token, \_token address is `0x0000000000000000000000000000000000000000`
* `_fee`: increase fee amount

increaseBridgeFee event

```solidity
event IncreaseBridgeFee(
    address indexed sender,
    address indexed token,
    string chain,
    uint256 txID,
    uint256 fee
);
```

* `sender`: the sender address
* `token`: the address of cross chain fee token
* `chain`: the module name of the cross chain, like eth, bsc, etc.
* `txID`: the txid of the cross chain transaction
* `fee`: increase fee amount
